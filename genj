#!/usr/bin/perl
use strict;
use warnings;

my $namespace = 'jstr_';
my $namespace_big = 'JSTR';

while (glob('*.h')) {
	open(my $FH, '<', $_);
	my $s;
	while (<$FH>) {
		$s .= $_;
	}
	close($FH);
	my @funcs = split(/\n\n/, $s);
	foreach (@funcs) {
		$_ =~ /^((?:\/\/|\/\*|$namespace_big|static)[^(){}]+?($namespace\w+?)\(((?:.|\n)+?(?:sz|cap)(?:.|\n)+?\)))/;
		if (!$1 && !$2 && !$3) {
			next;
		}
		my $decl = $1;
		my $func = $2;
		my $args = $3;
		my $has_sz = 0;
		my $has_cap = 0;
		if (index($args, 'sz') != -1) {
			$has_sz = 1;
		}
		if (index($args, 'cap') != -1) {
			$has_cap = 1;
		}
		if (!$has_sz && !$has_cap) {
			next;
		}
		$args =~ s/\)/,/;
		my @new_args;
		my @types;
		my $argnum = 0;
		{
			my @old_args = split(/\s/, $args);
			my $i = 0;
			foreach (@old_args) {
				if (/,$/) {
					s/,//;
					push(@new_args, $_);
					++$i;
				}
				$types[$i] .= "$_ ";
				++$argnum;
			}
		}
		my $comma1 = 0;
		if ($has_sz) {
			$decl =~ s/\((?:.|\n)+?sz(,|\))/(/;
			if ($1 eq ',') {
				$comma1 = 1;
			}
		}
		my $comma2 = 0;
		if ($has_cap) {
			$decl =~ s/\((?:.|\n)+?cap(,|\))/(/;
			if ($1 eq ',') {
				$comma2 = 1;
			}
		}
		my $tmp = '';
		if ($comma1 || $comma2) {
			$tmp = ',';
		}
		$decl =~ s/\(/(jstr_t *j$tmp/;
		$decl .= "\n{\n\t$func(";
		my $func_args;
		for (my $i = 0; $i < $#new_args; ++$i) {
			if (index($new_args[$i], 'sz') != -1) {
				$new_args[$i] = "&j->sz";
			} elsif (index($new_args[$i], 'cap') != -1) {
				$new_args[$i] = "&j->cap";
			} elsif ($i == 0) {
				$new_args[$i] = "j->data";
			}
			$func_args .= "$new_args[$i], ";
		}
		$func_args =~ s/,[^,]*$//;
		$decl .= "$func_args);\n}\n\n";
		$decl =~ s/$func/$func\_j/;
		print $decl;
	}
}
